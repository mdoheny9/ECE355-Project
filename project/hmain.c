// This file is part of the GNU ARM Eclipse distribution.
// Copyright (c) 2014 Liviu Ionescu.

// ----------------------------------------------------------------------------
// School: University of Victoria, Canada.
// Course: ECE 355 "Microprocessor-Based Systems".
// Template code for Part 2 of Introductory Lab
//
// See "system/include/cmsis/stm32f051x8.h" for register/bit definitions.
// See "system/src/cmsis/vectors_stm32f051x8.c" for handler declarations.
// ----------------------------------------------------------------------------

#include <stdio.h>
#include "diag/Trace.h"
#include "cmsis/cmsis_device.h"

// ----------------------------------------------------------------------------
/* Specifications:

• In Part 2 of the introductory lab, you have used the Function Generator to generate a
square-wave signal. For this project, you will also use the 555 timer to generate an
additional square-wave PWM signal. An interrupt request must be raised whenever the
USER button is pressed, and the corresponding interrupt handler must “force” TIM2
to switch between measuring the Function Generator signal frequency and measuring
the 555 timer signal frequency.
IMPORTANT: You must use PA0 with EXTI0 for the USER button interrupts, PB3
with EXTI3 for measuring the 555 timer signal frequency, and PB2 with EXTI2 for
measuring the Function Generator signal frequency (as in Part 2 of the introductory
lab).

• The STM32F051R8T6 MCU mounted on the STM32F0 Discovery board features
internal analog-to-digital converter (ADC) and digital-to-analog converter (DAC).
The DAC will be used to drive the optocoupler to adjust the signal frequency and duty
cycle of the 555 timer output, based on the potentiometer voltage read by the ADC.

• The analog voltage signal coming from the potentiometer on the PBMCUSLK board
will be measured continuously by the ADC – this task is to be accomplished using a
polling approach. Using those voltage measurements, you will need to calculate the
corresponding potentiometer resistance value. You must also determine the lower and
the upper limits of the measurable voltage.

• You will use the digital value obtained from the ADC to control the frequency of the
PWM signal generated by the 555 timer. For that purpose, you will use the DAC to
convert that digital value to an analog voltage signal driving the optocoupler.

• To display the measured signal frequency and the potentiometer resistance, you will
use the SPI (to be appropriately configured) to drive the LED Display mounted on the
PBMCUSLK board. The interface includes 1 serial data signal (SDIN = SPI MOSI),
1 clock signal (SCLK = SPI SCK), and 3 control signals (RES#, CS#, D/C#). These
signals and their associated pin information are shown in the table below

*/
// --------------------------------------------------------------------

// Sample pragmas to cope with warnings. Please note the related line at
// the end of this function, used to pop the compiler diagnostics status.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#pragma GCC diagnostic ignored "-Wreturn-type"


/* Definitions of registers and their bits are given in system/include/cmsis/stm32f051x8.h */

/* Clock prescaler for TIM2 timer: no prescaling */
#define myTIM2_PRESCALER ((uint16_t)0x0000)
/* Maximum possible setting for overflow */
#define myTIM2_PERIOD ((uint32_t)0xFFFFFFFF)

void myGPIOB_Init(void);
void myTIM2_Init(void);
void myEXTI_Init(void);


// Declare/initialize your global variables here...

int firstEdge = 1;


/*** Call this function to boost the STM32F0xx clock to 48 MHz ***/
void SystemClock48MHz(void) {
//
// Disable the PLL
//
    RCC->CR &= ~(RCC_CR_PLLON);
//
// Wait for the PLL to unlock
//
    while (( RCC->CR & RCC_CR_PLLRDY ) != 0 );
//
// Configure the PLL for 48-MHz system clock
//
    RCC->CFGR = 0x00280000;
//
// Enable the PLL
//
    RCC->CR |= RCC_CR_PLLON;
//
// Wait for the PLL to lock
//
    while (( RCC->CR & RCC_CR_PLLRDY ) != RCC_CR_PLLRDY );
//
// Switch the processor to the PLL clock source
//
    RCC->CFGR = ( RCC->CFGR & (~RCC_CFGR_SW_Msk)) | RCC_CFGR_SW_PLL;
//
// Update the system with the new clock frequency
//
    SystemCoreClockUpdate();
}


void displayToScreen(int resistance, int frequency) {
    /*
    To display the measured signal frequency and the potentiometer resistance, you will
    use the SPI (to be appropriately configured) to drive the LED Display mounted on the
    PBMCUSLK board. The interface includes 1 serial data signal (SDIN = SPI MOSI),
    1 clock signal (SCLK = SPI SCK), and 3 control signals (RES#, CS#, D/C#). These
    signals and their associated pin information are shown in the table below
    */

    // "R: %d Ohms"
    // "F: %d Hz"
    // Delay until TA releases better info?
}


int main(int argc, char* argv[]) {
	SystemClock48MHz();

	trace_printf("System clock: %u Hz\n", SystemCoreClock);

    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGCOMPEN;  /* Enable SYSCFG clock */

	myGPIOB_Init();		/* Initialize I/O port PB */
	myTIM2_Init();		/* Initialize timer TIM2 */
	myEXTI_Init();		/* Initialize EXTI */

	while (1) {
        /*
		The analog voltage signal coming from the potentiometer on the PBMCUSLK board
        will be measured continuously by the ADC – this task is to be accomplished using a
        polling approach. Using those voltage measurements, you will need to calculate the
        corresponding potentiometer resistance value. You must also determine the lower and
        the upper limits of the measurable voltage.
        */


        // Chat says:
        // Vout = (ADC * Vref) / 2^Bits
        // Vref: The reference voltage. This is the maximum voltage the ADC can measure (e.g., \(5V\) or \(3.3V\))
        // Bits: The resolution of the ADC (e.g., \(8\)-bit, \(10\)-bit, or \(16\)-bit).

        // Rbot = Rt * (Vcc/​Vout)​​ OR = 5000 * (ADC/2^bitresolution-1)
        // Rt = 5000 ohms
        
        // Datasheet says:
        VCHANNELx = (3.3 * VREFINT_CAL * ADC_DATAx) / (VREFINT_DATA * FULL_SCALE)

        // full scale = 2^bitresolution - 1

        /*
        You will use the digital value obtained from the ADC to control the frequency of the
        PWM signal generated by the 555 timer. For that purpose, you will use the DAC to
        convert that digital value to an analog voltage signal driving the optocoupler.
        */
	}

	return 0;

}


void myGPIOB_Init() {
	/* Enable clock for GPIOB peripheral */
	// Relevant register: RCC->AHBENR
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

	/* Configure PB2 as input */
	// Relevant register: GPIOB->MODER
	GPIOB->MODER &= ~(GPIO_MODER_MODER2);

	/* Ensure no pull-up/pull-down for PB2 */
	// Relevant register: GPIOB->PUPDR
	GPIOB->PUPDR &= ~(GPIO_PUPDR_PUPDR2);
}


void myTIM2_Init() {
	/* Enable clock for TIM2 peripheral */
	// Relevant register: RCC->APB1ENR
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	/* Configure TIM2: buffer auto-reload, count up, stop on overflow,
	 * enable update events, interrupt on overflow only */
	// Relevant register: TIM2->CR1
	TIM2->CR1 = ((uint16_t)0x008C);

	/* Set clock prescaler value */
	TIM2->PSC = myTIM2_PRESCALER;
	/* Set auto-reloaded delay */
	TIM2->ARR = myTIM2_PERIOD;

	/* Update timer registers */
	// Relevant register: TIM2->EGR
	TIM2->EGR = ((uint16_t)0x0001);

	/* Assign TIM2 interrupt priority = 0 in NVIC */
	// Relevant register: NVIC->IP[3], or use NVIC_SetPriority
	NVIC_SetPriority(TIM2_IRQn, 0);

	/* Enable TIM2 interrupts in NVIC */
	// Relevant register: NVIC->ISER[0], or use NVIC_EnableIRQ
	NVIC_EnableIRQ(TIM2_IRQn);

	/* Enable update interrupt generation */
	// Relevant register: TIM2->DIER
	TIM2->DIER |= TIM_DIER_UIE;
}


void myEXTI_Init() {
	/* Map EXTI2 line to PB2 */
	// Relevant register: SYSCFG->EXTICR[0]
	SYSCFG->EXTICR[0] = SYSCFG_EXTICR1_EXTI2_PB;

	/* EXTI2 line int
	 * errupts: set rising-edge trigger */
	// Relevant register: EXTI->RTSR
	EXTI->RTSR = EXTI_RTSR_TR2;

	/* Unmask interrupts from EXTI2 line */
	// Relevant register: EXTI->IMR
	EXTI->IMR = EXTI_IMR_MR2;

	/* Assign EXTI2 interrupt priority = 0 in NVIC */
	// Relevant register: NVIC->IP[2], or use NVIC_SetPriority
	NVIC_SetPriority(EXTI2_3_IRQn, 0);

	/* Enable EXTI2 interrupts in NVIC */
	// Relevant register: NVIC->ISER[0], or use NVIC_EnableIRQ
	NVIC_EnableIRQ(EXTI2_3_IRQn);
}


/* This handler is declared in system/src/cmsis/vectors_stm32f051x8.c */
void TIM2_IRQHandler() {
	/* Check if update interrupt flag is indeed set */
	if ((TIM2->SR & TIM_SR_UIF) != 0)
	{
		trace_printf("\n*** Overflow! ***\n");

		/* Clear update interrupt flag */
		// Relevant register: TIM2->SR
		TIM2->SR &= ~(TIM_SR_UIF);

		/* Restart stopped timer */
		// Relevant register: TIM2->CR1
		TIM2->CR1 |= TIM_CR1_CEN;
	}
}


/* This handler is declared in system/src/cmsis/vectors_stm32f051x8.c */
void EXTI2_3_IRQHandler() {
	float period = 1;
	float frequency = 0;

	/* Check if EXTI2 interrupt pending flag is indeed set */
	if ((EXTI->PR & EXTI_PR_PR2) != 0) {
		//
		// 1. If this is the first edge:
		if (firstEdge) {
			//	- Clear count register (TIM2->CNT).
			TIM2->CNT = 0x00;
			//	- Start timer (TIM2->CR1).
			TIM2->CR1 |= TIM_CR1_CEN;

			firstEdge = 0;
		}
		else {
			//    Else (this is the second edge):
			//	- Stop timer (TIM2->CR1).
			TIM2->CR1 &= ~(TIM_CR1_CEN);
			//	- Read out count register (TIM2->CNT).
			period = TIM2->CNT;
			period /= 48172691.6; // Average of 10 runs on 1 second

			//	- Calculate signal period and frequency.
			frequency = 1.0/period;

			//	- Print calculated values to the console.
			trace_printf("period: %.10fs\n", period);
			trace_printf("frequency: %fHz\n", frequency);

			firstEdge = 1;
		}

		// 2. Clear EXTI2 interrupt pending flag (EXTI->PR).
		// NOTE: A pending register (PR) bit is cleared
		// by writing 1 to it.

		EXTI->PR |= EXTI_PR_PR2;
	}
}


#pragma GCC diagnostic pop
